# سیستم‌های عامل - تمرین گروهی دوم

## مشخصات گروه

>> نام، نام خانوادگی و ایمیل خود را در ادامه وارد کنید.


محمد مهدی صادقی moh02sadeghi@gmail.com

آرش یادگاری arashyadegari0402@gmail.com

محمد خسروی mohamad138121@gmail.com

عرفان مجیبی mojibierfan@gmail.com

## مقدمه

>> اگر نکته‌ای درباره فایل‌های سابمیت شده یا برای TAها دارید، لطفا اینجا بیان کنید.

>> اگر از هر منبع برخط یا غیر برخطی به غیر از مستندات Pintos، متن درس، اسلایدهای درس یا نکات گفته شده در کلاس در تمرین گروهی استفاده کرده‌اید، لطفا اینجا آن(ها) را ذکر کنید.

## ساعت زنگ‌دار

### داده ساختارها

>> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در 25 کلمه یا کمتر توضیح بنویسید.

یک لیست برای نگه‌داری ریسه‌های خفته:
```C
struct list sleeping_threads;
```
یک سمافور sleep_sema و یک int64_t برای زمان بیدار شدن به استراکت thread اضافه می‌کنیم.
```C
struct semaphore sleep_sema;
int64_t wakeup_time;  
```
و علاوه بر این دو، یک list_elem جدید برای sleep استفاده می‌کنیم.

```C
struct list_elem sleep_elem;
```

### الگوریتم

>> پرسش دوم: به اختصار آن‌چه هنگام صدا زدن تابع `timer_sleep()` رخ می‌دهد و همچنین اثر `timer interrupt handler` را توضیح دهید.


ابتدا زمانی را که باید ریسه بیدار شود پیدا می‌کنیم. این کار را با جمع زدن timer_ticks() و ticks انجام می‌دهیم. سپس وقفه‌ها را غیرفعال می‌کنیم و زمانی که به دست آوردیم را به همراه مشخصات ترد به یک لیست اضافه می‌کنیم و بعد از آن وقفه‌ها را فعال می‌کنیم. در نهایت روی یک سمافور تعریف شده درون ترد sema_down را فراخوانی می‌کنیم.

در timer interrupt handler اگر در لیست ذکر شده تردی باشد که از زمان بیدار شدنش گذشته باشد روی سمافور آن sema_up را فراخوانی می‌کنیم.


>> پرسش سوم: مراحلی که برای کوتاه کردن زمان صرف‌شده در `timer interrupt handler` صرف می‌شود را نام ببرید.

لیست پیوندی ریسه‌های خفته را به صورت صعودی مرتب نگه‌میداریم تا هنگامی که می‌خواهیم در لیست جست و جو کنیم، تا زمانی ادامه دهیم که تیک‌ مربوطه از تیک فعلی بزرگ‌تر باشد.

### همگام‌سازی

>> پرسش چهارم: هنگامی که چند ریسه به طور همزمان `timer_sleep()` را صدا می‌زنند، چگونه از `race condition` جلوگیری می‌شود؟

از یک `lock` استفاده می‌کنیم تا زمانی که تابع `timer_sleep()` صدا زده می‌شود، از دسترسی مشترک آنها به داده‌ساختار نگه‌دارنده `sleeping_thread` جلوگیری کنیم.

>> پرسش پنجم: هنگام صدا زدن `timer_sleep()` اگر یک وقفه ایجاد شود چگونه از `race condition` جلوگیری می‌شود؟

با استفاده از `diable_intr()` از وقوع این حالت جلوگیری می‌کنیم.

این تابع مقدار پرچمی که بیانگر وقوع وقفه در پردازنده x8086 است را تغییر می‌دهد.  

### منطق

>> پرسش ششم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.

ساده‌ترین راهی که به ذهن می‌رسد، نگه‌داری ریسه‌ها در لیست پیوندی است تا در زمان لازم بیدار شوند.

## زمان‌بند اولویت‌دار

### داده ساختارها

>> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در ۲۵ کلمه یا کمتر توضیح بنویسید.

برای پیاده‌سازی `priority donation` لازم است تا تغییراتی در `struct thread` و `struct lock` ایجاد کنیم. 

تغییرات لازم برای `thread` :‌

‍‍‍‍‍‍<div>
```C
struct thread
  {
    /* ... Other fields ... */

    int priority;               /* Priority. */
    int donated_priority;       /* Donated priority. */
    struct list held_locks;     /* Locks acquired by the thread */

    /* ... Other fields ... */
  };
  ```
</div>

همانطور که مشاهده می‌کنید علاوه بر `priority` یک فیلد دیگر به نام `donated_priority`وجود دارد.

این فیلد برای انتساب اولویت به ریسه است  که در قسمت بعدی شرایطی که این انتساب رخ می‌دهد توضیح داده می‌شود.

تغییرات لازم برای `lock`:

‍‍‍‍‍‍<div>
```C
struct lock
  {
    /* ... Other fields ... */

    struct list_elem elem;      /* List element for priority donation. */
    struct thread *donating_thread; /* Thread donating priority. */
    int max_donated_priority; /* Maximum donated priority of waiting threads. */

    /* ... Other fields ... */
  };

  ```
</div>

>> پرسش دوم: داده‌ساختارهایی که برای اجرای `priority donation` استفاده شده‌است را توضیح دهید. (می‌توانید تصویر نیز قرار دهید)

داده‌ساختارهای پرسش اول برای پیاده‌سازی این فرآیند می‌باشند. زمانی که یک قفل در اختیار یک ریسه قرار می‌گیرد، ممکن است یک ریسه دیگر با اولویت بالاتر نیاز به آن قفل داشته باشد. در این شرایط مقدار اولویت آن در صورت بیشتر بودن،
جایگزین `donated_priority` می‌شود.

ریسه‌هایی که نیازمند به قفل اشغل شده توسط یک ترد دیگر هستند در `elem` ذخیره می‌شوند تا پس از آن که ریسه‌ای که فقل را در اختیار دارد بتواند میزان priority خود را بازیابی کند. برای بازیابی ابتدا `elem` را از `held_locks` حذف کرده و سپس اولویت آن را با استفاده از مقدار اولیه آن `priority` و `max_donated_priority` در `lock` های دیگری که توسط این ریسه در اختیار گرفته شده است بدست می‌آوریم.

### الگوریتم

>> پرسش سوم: چگونه مطمئن می‌شوید که ریسه با بیشترین اولویت که منتظر یک قفل، سمافور یا `condition variable` است زودتر از همه بیدار می‌شود؟

با تغییر ساختار انتخاب ریسه بر اساس اولویت (یعنی ریسه‌ای که بیشترین اولویت را دارد توسط `same_phore` فعال می‌شود.) همواره ریسه با بیشترین اولویت (`donated_priority`) انختاب می‌شود.

>> پرسش چهارم: مراحلی که هنگام صدازدن `lock_acquire()` منجر به `priority donation` می‌شوند را نام ببرید. دونیشن‌های تو در تو چگونه مدیریت می‌شوند؟

اگر قفل درخواست شده توسط ریسه، در اختیار ریسه دگیری نباشد نیاز به `priority_donation` وجود ندارد.

در صورتی که قفل خواسته شده در اختیار ترد دیگری بود (فرض کنید T1 قفل را در اختیار داشته و T2 خواستار قفل است.) آنگاه بررسی می‌شود که آیا T2 اولویت بیشتری داشته یا نه دقت شود که منظور از اولویت، `priority_donation` است چرا که ممکن است خود این قفل نیز در مراحل قبلی از الویت یک ترد دیگر استفاده کرده باشد. در صورتی که مقدار اولویت بیشتری داشته باشد، مقدار اولیوت آن به ریسه در اختیار دارنده قفل (در یاانجا T1) داده می‌شود. 
دقت کنید که حالت تو در تو نیز به همین شکل پوشش داده می‌شود.

>> پرسش پنجم: مراحلی که هنگام صدا زدن `lock_release()` روی یک قفل که یک ریسه با اولویت بالا منتظر آن است، رخ می‌دهد را نام ببرید.

همانطور که در قسمت‌ داده‌ساختار توضیح داده شد، پس از آزاد شدن قفل نیاز است تا مقدار اولویت ریسه محاسبه شود. مقدار کمینه این اولویت، مقدار اولیه اولویت ریسه است. برای بدست آوردن اولویت ریسه پس از آزاد شدن قفل کافی است تا بر روی قفل‌های دیگر اشغال شده توسط این ریسه پیمایش کرده و بیشینه مقدار را به عنوان اولویت جدید ریسه تغیین کنیم.

### همگام‌سازی

>> پرسش ششم: یک شرایط احتمالی برای رخداد `race condition` در `thread_set_priority` را بیان کنید و توضیح دهید که چگونه پیاده‌سازی شما از رخداد آن جلوگیری می‌کند. آیا می‌توانید با استفاده از یک قفل از رخداد آن جلوگیری کنید؟

### منطق

>> پرسش هفتم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.

## سوالات افزون بر طراحی

>> پرسش هشتم: در کلاس سه صفت مهم ریسه‌ها که سیستم عامل هنگامی که ریسه درحال اجرا نیست را ذخیره می‌کند، بررسی کردیم:‍‍ `program counter` ، ‍‍‍`stack pointer` و `registers`. بررسی کنید که این سه کجا و چگونه در `Pintos` ذخیره می‌شوند؟ مطالعه ‍`switch.S` و تابع ‍`schedule` در فایل `thread.c` می‌تواند مفید باشد.

>> پرسش نهم: وقتی یک ریسه‌ی هسته در ‍`Pintos` تابع `thread_exit` را صدا می‌زند، کجا و به چه ترتیبی صفحه شامل پشته و `TCB` یا `struct thread` آزاد می‌شود؟ چرا این حافظه را نمی‌توانیم به کمک صدازدن تابع ‍`palloc_free_page` داخل تابع ‍`thread_exit` آزاد کنیم؟

>> پرسش دهم: زمانی که تابع ‍`thread_tick` توسط `timer interrupt handler` صدا زده می‌شود، در کدام پشته اجرا می‌شود؟

>> پرسش یازدهم: یک پیاده‌سازی کاملا کاربردی و درست این پروژه را در نظر بگیرید که فقط یک مشکل درون تابع ‍`sema_up()` دارد. با توجه به نیازمندی‌های پروژه سمافورها(و سایر متغیرهای به‌هنگام‌سازی) باید ریسه‌های با اولویت بالاتر را بر ریسه‌های با اولویت پایین‌تر ترجیح دهند. با این حال پیاده‌سازی ریسه‌های با اولویت بالاتر را براساس اولویت مبنا `Base Priority` به جای اولویت موثر ‍`Effective Priority` انتخاب می‌کند. اساسا اهدای اولویت زمانی که سمافور تصمیم می‌گیرد که کدام ریسه رفع مسدودیت شود، تاثیر داده نمی‌شود. تستی طراحی کنید که وجود این باگ را اثبات کند. تست‌های `Pintos` شامل کد معمولی در سطح هسته (مانند متغیرها، فراخوانی توابع، جملات شرطی و ...) هستند و می‌توانند متن چاپ کنند و می‌توانیم متن چاپ شده را با خروجی مورد انتظار مقایسه کنیم و اگر متفاوت بودند، وجود مشکل در پیاده‌سازی اثبات می‌شود. شما باید توضیحی درباره این که تست چگونه کار می‌کند، خروجی مورد انتظار و خروجی واقعی آن فراهم کنید.

## سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد. نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست. ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>> به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>> آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>> آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>> آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>> آیا حرف دیگری دارید؟
