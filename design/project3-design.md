تمرین گروهی ۳ - مستند طراحی
======================

گروه
-----

>>‫نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

محمد مهدی صادقی <moh02sadeghi@gmail.com>

آرش یادگاری <arashyadegari0402@gmail.com>

محمد خسروی <mohamad138121@gmail.com>

عرفان مجیبی <mojibierfan@gmail.com>

مقدمات
----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```C
#define BUFFER_CACHE_SIZE 64;     /* Number of buffer cache blocks */

struct list buffer_cache_list;    /* List of buffer cache blocks */
struct lock buffer_cache_lock;    /* Lock for modifying buffer_cache_list */

struct buffer_cache_block
  {
    block_sector_t sector;            /* Index of sector */         
    char data[BLOCK_SECTOR_SIZE];     /* Sector's data */
    struct lock block_lock;           /* Lock for accessing block */
    bool valid;                       /* Valid bit */
    bool dirty;                       /* Dirty bit */
  }

/* Initializes buffer cache */
void buffer_cache_init ();

/* Reads from the sector */
void buffer_cache_read (block_sector_t sector, void void *buffer, off_t size, off_t block_ofs);

/* Writes at the sector */
void buffer_cache_write (block_sector_t sector, const void *buffer, off_t size, off_t block_ofs);

/* Writes all dirty blocks to disk */
void buffer_cache_flush ();
```

الگوریتم‌ها
------------

تابع `buffer_cache_init`:
به تعداد `BUFFER_CACHE_SIZE` از استراکت `buffer_cache_block` می‌سازد و به لیست `buffer_cache_list` اضافه می‌کند. برای هر `buffer_cache_block،` بیت valid برابر با ۰ قرار داده می‌شود و به لاک `block_lock` مقدار اولیه داده می‌شود.

تابع‌های `buffer_cache_read` و `buffer_cache_write`:
اگر سکتور مورد نظر در بافر کش باشد، عملیات خواندن یا نوشتن در بافر کش انجام می‌شود و آن بلاک به ابتدای لیست منتقل می‌شود. اگر عملیات نوشتن باشد، بیت `dirty` برابر با ۱ قرار داده می‌شود.
اگر سکتور مورد نظر در بافر کش نباشد، علاوه عملیات خواندن یا نوشتن روی دیسک انجام می‌شود و سکتور وارد بافر کش می‌شود. اگر بیت `dirty` بلاکی که از بافر کش خارج می‌شود برابر ۱ باشد، داده‌های آن روی دیسک نوشته می‌شود.

تابع `buffer_cache_flush`:
بلاک‌های `dirty` را روی دیسک می‌نویسد و بیت `dirty` آن‌ها را برابر ۰ قرار می‌دهد.

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟

لیست `buffer_cache_list` بر حسب زمان آخرین دسترسی مرتب شده‌است به طوری که بلاکی  که زمان دسترسی به آن از بقیه قدیمی‌تر باشد در انتهای لیست قرار دارد.
زمانی که به یک بلاک دسترسی می‌شود، آن بلاک را از لیست حذف و به ابتدای آن اضافه می‌کنیم. همچنین وقتی یک بلاک وارد بافر کش می‌شود آن را به ابتدای آن اضافه می‌کنیم. در نتیجه آخرین بلاک لیست همیشه قدیمی‌ترین زمان دسترسی را دارد در زمان O(1) انتخاب می‌شود.

>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.

اگر داده مورد نظر در بافر کش نباشد، علاوه بر سکتوری که داده در آن قرار دارد، سکتوری بعدی را نیز وارد بافر کش می‌کنیم.

همگام سازی
-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟

زمانی که یک پردازه در حال خواندن یا نوشتن داده در یک بلاک می‌باشد، لاک `block_lock` آن بلاک را می‌گیرد و در نتیجه سایر پردازه‌ها نمی‌توانند به آن بلاک دسترسی پیدا کنند.

>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟

مشابه پاسخ قسمت قبل، `block_lock` مانع این اتفاق می‌شود.

منطق طراحی
-----------------

>>‫ یک سناریو را توضیح دهید که  بافر کش از `read-ahead` و یا از `write-behind` استفاده کند.

زمانی که در حال خواندن یک فایل بزرگ که در چند سکتور قرار دارند باشیم،  قبل از اولین دسترسی به یک سکتور، آن سکتور وارد کش می‌شود و در نتیجه زمان دسترسی به آن کاهش می‌یابد.

اگر به صورت غیر منتظره سیستم خاموش شود (مثلا برق برود) داده‌های dirty درون کش که روی دیسک نوشته نشده‌اند از دست می‌روند. اما اگر write-behind انجام شود داده‌ها از دست نمی‌روند.

فایل‌های قابل گسترش
=====================

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

`inode.c`
```C
#define DIRECT_BLK_CNT 123
#define IND_BLK_CNT 128
#define DBL_IND_BLK_CNT 128
```
```C
struct inode_disk {
  block_sector_t db[DIRECT_BLK_CNT];    /* direct blocks */
  indirect_block ib;                    /* indirect block */
  double_indirect_block dib;                  /* double indirect block */
  off_t length;                       /* File size in bytes. */
  unsigned magic;                     /* Magic number. */
};
```
تغییرات برای طبقه‌بندی چندسطحی در inode. حذف start و unsued.

```C
struct inode
  {
    // Others ...
    struct lock inode_lock;    // inode lock
  };
```
قفل برای جلوگیری از حالت مسابقه.

```C
struct indirect_block {
  block_sector_t blocks[IND_BLK_CNT];
};

struct double_indirect_block {
  block_sector_t indirect_blocks[DBL_IND_BLK_CNT];
};
```
برای طبقه‌بندی چند سطحه.

```C
static bool allocate_inode (struct inode_disk, off_t);
static void free_inode (struct inode);
```
این دو تابع برای گسترش و حذف inode استفاده خواهند شد.
>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟

512 * (123 + 128 + 128 * 128) = 8517632 B = 8.5 MB

همگام سازی
----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.

هرگاه بخواهیم به یک فایل دسترسی داشته باشیم با استفاده از inode_lock از حالت مسابقه جلوگیری می‌کنیم (فقط یکی از پردازه‌ها خواهد توانست قفل را به دست آورد).

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.

همانطور که در قسمت قبل بیان شد، هر گاه بخواهیم به یک فایل دسترسی داشته باشیم باید از  inode_lock استفاده کنیم. و بنابراین در مسئله مطرح شده دو حالت وجود دارد:

۱. ریسه A ابتدا قفل را بگیرد. که در این صورت ابتدا EOF را می‌خواند و سپس قفل را رها می‌کند و ریسه B شروع به نوشتن می‌کند.
۲. ریسه B ابتدا قفل را بگیرد. که در این صورت ابتدا B تمام چیزهایی که می‌خواهد را می‌نویسد و سپس قفل را رها می‌کند تا A تمام محتویاتی که B نوشته است را بخواند.

>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.

از آنجا که انتخاب بین پردازه‌ای که ابتدا قفل را می‌گیرد به صورت تصادفی انجام می‌گیرد، پس انتخاب پردازه‌ی بعدی‌ای که اجرا می‌شود به سمتی سوگیری ندارد و در نهایت به طور عادلانه هم خواننده و هم نویسنده‌ها اجرا می‌شوند.

منطق طراحی
----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.

بله پشتیبانی می‌کند. اشاره‌گر مستقیم کمک می‌کند که بدون سر بار و با سرعت زیاد به فایل دسترسی داشته باشیم. اشاره‌گر غیر مستقیم کمک می‌کند که بتوانیم اندازه فایل را بیشتر کنیم بدون اینکه تغییری در اندازه inode بدهیم. و همینطور برای double indrect می‌توانیم یک فایل به مراتب بزرگ‌تر را ذخیره کنیم.

زیرمسیرها
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```C

// add struct current working directory to thread
struct thread {
  ...
  struct dir cwd:
  ...
}

// based on our research the base pintOS implementation 
// file descriptors instead of saving it on a different 
// data type therefore adding it to thread can be a good
// solution based on our prev implementation



// add is_dir bool to inode_disk
struct inode_disk
{
  ...
  bool is_dir; 
  ...
}

// this bool will help inode to know if it is a file or a dir 

```

الگوریتم‌ها
-----------

>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟

یافتن مسیرهای نسبی و مطلق متفاوت می‌باشد.
ابتدا بررسی می‌کنیم که آدرس داده شده نسبی است و یا مطلق. برای اینکار کافی است که به کاراکتر اول آدرس داده شده نگاه کنیم و در صورتی که با `/` شروع می‌شد آدرس مطلق و در غیر این صورت آدرس نسبی می‌باشد. 

در صورتی که آدرس مطلق باشد از تابع `dir_open_root`  برای بدست آوردن `root's dir` استفاده می‌کنیم.  در صورت نسبی بودن آدرس از داده `cwd` درون `current_thread` استفاده می‌کنیم.

سپس به صورت بازگشتی به دنبال آدرس مدنظر بر روی `curr_dir` می‌گردیم تا به آدرس مدنظر دست پیدا کنیم.

توجه شود که مقدار `curr_dir` همان مقداری است که با توجه به `cwd` و یا `dir_open_root`  بدست‌ آمده است.

همگام سازی
-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟


برای جلوگیری از ایجاد  `race_condition` می‌توانیم از `lock` تعریف شده در `syscall.c` استفاده کنیم همانگونه که برای دستوراتی سیستمی که در فاز ۱ پیاده شدند استفاده نمودیم.

منطق طراحی
-----------------

>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟

همانطور که در قسمت ابتدایی پیان شد، پیاده‌سازی کنونی برای ساده‌سازی می‌باشد و بهتر است که ‍‍`cwd` توسط جدول نگه‌دارنده `fd` ها ذخیره شود. برای جلوگیری از `race_conditon` هم می‌توان از پیاده‌سازی `lock` در `inode` و یا `dir` استفاده نمود اما برای آنکه تغییرات نسبت به فاز ۱ کمینه باشد طراحی کنونی را مدنظر گرفتیم.


### سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد.

نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست.

ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>>‫ به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>>‫ آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>>‫ آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>>‫ آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>>‫ آیا حرف دیگری دارید؟
