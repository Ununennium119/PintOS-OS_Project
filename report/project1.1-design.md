# تمرین گروهی ۱.۱ - مستند طراحی

## گروه ۲

 >
 > نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

محمد مهدی صادقی moh02sadeghi@gmail.com

آرش یادگاری arashyadegari0402@gmail.com

محمد خسروی mohamad138121@gmail.com

عرفان مجیبی mojibierfan@gmail.com

## مقدمات

>
> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  بنویسید.

\-

> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

\-

## پاس‌دادن آرگومان

### داده‌ساختار‌ها

>
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```C
#define MAX_ARGS = 30;  // maximum number of arguments for the program
```

### الگوریتم‌ها

>
> به‌طور خلاصه توضیح دهید چگونه آرگومان‌ها را پردازش کرده‌اید؟ چگونه اعضای `argv[]` را به ترتیب درست در پشته قرار داده‌اید؟ و چگونه از سرریز پشته جلوگیری کرده‌اید؟

 ابتدا به کمک تابع `strtok_r()` آرگومان‌ها را جدا کرده و در یک متغیر محلی ذخیره‌ می‌کنیم. مقدار argc در زمان جداسازی آرگومان‌ها محاسبه می‌شود.
اصل رشته‌ها به همراه آدرس آنها را (که همان آرگومان‌ها هستند) در استک پردازه کپی می‌کنیم. همچنین آدرس اولین آرگومان را نیز در استک به همراه تعداد آرگومان‌ها کپی می‌کنیم.

برای جلوگیری از پر شدن استک از مقدار `Magic' برای کنترل سایز آن استفاده می‌کنیم.
این مقدار به این صورت تعریف شده است که مقداری از حافظه استک را با فرض آنکه ممکن است توسط کرنل استفاده شود کنار می‌گذارد و اگر سایز باقی مقادیر داخل استک بیش از سایز استک شود، سرریز رخ می‌دهد. به عبارتی

`if ($sp <= MAGIC) -> overflow)`

### منطق طراحی

>
> چرا Pintos به‌جای تابع‌ `strtok()` تابع‌ `strtok_r()` را پیاده‌سازی کرده‌است؟

با توجه به اینکه این تابع یک آرگومان به نام save_ptr دارد که آدرس ادامه رشته را ذخیره می‌کند، بنابراین این تابع می‌تواند توسط چند ریسه‌ی مختلف به صورت هم‌زمان استفاده شود.

> در Pintos عمل جدا کردن نام فایل از آرگومان‌ها، در داخل کرنل انجام می‌شود. در سیستم عامل‌های برپایه‌ی Unix، این عمل توسط shell انجام می‌شود. حداقل دو مورد از برتری‌های رویکرد Unix را توضیح دهید.

با توجه به اینکه shell به اطلاعات محیطی متعددی دسترسی دارد، اینکه ما در shell آرگومان‌ها را جدا کنیم، این فایده را دارد که بتوانیم انعطاف پذیری بیشتری به آن بدهیم.

به عنوان مثال، می‌توانیم با استفاده از متغیر محیطی PATH، به جای دادن مسیر مطلق، صرفا نام دستور را بدهیم.

همینطور می‌توانیم از ویژگی‌های دیگری مانند wildcard و autocomplete استفاده کنیم، که به طبع باعث استفاده راحت‌تر توسط کاربر می‌شود.

## فراخوانی‌های سیستمی

### داده‌ساختار‌ها

>
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ای.جاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```C
struct thread_child_status {
    pid_t pid;
    int exit_code;

    int reference_count;
    struct lock rc_lock;

    struct semaphore wait_sema;

    struct list_elem elem;
}
```

```C
struct thread {
    ...
    struct thread_child_status *tc_statuc;
}
```

> توضیح دهید که توصیف‌کننده‌های فایل چگونه به فایل‌های باز مربوط می‌شوند. آیا این توصیف‌کننده‌ها در کل سیستم‌عامل به‌طور یکتا مشخص می‌شوند یا فقط برای هر پردازه یکتا هستند؟

در هر پردازه هرگاه که یک فایل باز می‌شود به آن یک عدد یکتا و داده می‌شود که در واقع در داخل آن پردازه، مانند اشاره‌گری به فایل عمل می‌کند.

اما خیر این توصیف‌کننده‌ها در کل سیستم‌عامل به صورت یکتا مشخص نمی‌شوند اما برای هر پردازه یکتا هستند. سیستم‌عامل اطمینان حاصل می‌کند که برای هر پردازه توصیف‌کننده‌های فایل به صورت یکتا مشخص شده باشند.

### الگوریتم‌ها

>
> توضیح دهید خواندن و نوشتن داده‌های کاربر از داخل هسته، در کد شما چگونه انجام شده است.

ابتدا معتبر بودن ورودی‌های داده شده را بررسی می‌کنیم (شامل file descriptor، بافر و اندازه بافر). سپس قفل مربوط به خواندن و نوشتن را می‌گیریم و بعد از انجام عملیات خواندن یا نوشتن آن را آزاد می‌کنیم.

اگر در حال خواندن باشیم و file descriptor برابر STDIN_FILENO باشد، داده‌ها را از ورودی می‌خوانیم و در بافر می‌ریزیم و در غیر این صورت فایل را باز می‌کنیم و داده‌ها را از فایل می‌گیریم.

اگر در حال نوشتن باشیم و file descriptor برابر STDOUT_FILENO باشد، داده‌ها را از بافر روی خروجی می‌نویسیم و در غیر این صورت فایل را باز می‌منیم و داده‌ها را روی فایل می‌نویسیم.

> فرض کنید یک فراخوانی سیستمی باعث شود یک صفحه‌ی کامل (۴۰۹۶ بایت) از فضای کاربر در فضای هسته کپی شود. بیشترین و کمترین تعداد بررسی‌‌های جدول صفحات (page table) چقدر است؟ (تعداد دفعاتی که `pagedir_get_page()` صدا زده می‌شود.) در‌ یک فراخوانی سیستمی که فقط ۲ بایت کپی می‌شود چطور؟ آیا این عددها می‌توانند بهبود یابند؟ چقدر؟

> پیاده‌سازی فراخوانی سیستمی `wait` را توضیح دهید و بگویید چگونه با پایان یافتن پردازه در ارتباط است.

به این صورت که ابتدا استراکت thread_child_status مربوط به پردازه فرزندی را که pid آن به عنوان پارامتر به تابع پاس داده شده است را پیدا می‌کنیم. سپس با sema_down روی سمافور wait_sema، پردازه پدر منتظر تمام شدن کار پردازه فرزند می‌ماند و پس از exit پردازه فرزند مقدارexit_code را آپدیت می‌کنیم. در نهایت اگر reference_count برابر ۱ باشد، منابع را آزاد می‌کنیم.

> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی `write‍` نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا (error handling) مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.

برای مواجه شدن با ارورها، و جدا کردن منطق مواجهه با آن‌ها از مفهوم اصلی کد، کاری که می‌کنیم این است که ماکرویی تعریف می‌کنیم به این صورت که شرط ارور را چک کند و در صورتی که شرط آن برقرار بود، تابع نشان‌دادن ارور را صدا می‌زنیم و با پاس دادن اشاره‌گر به حافظه‌های استفاده  شده، آن‌ها را free می‌کنیم.
مثال این استراتژی در واقع در خود کد اصلی پروژه آمده است. به ماکروی ASSERT توجه کنید. در صورتی که شرط برقرار باشد، با پاس دادن آرگومان‌های مرتبط، ارور را هندل می‌کند.

### همگام‌سازی

>
> فراخوانی سیستمی `exec` نباید قبل از پایان بارگذاری فایل اجرایی برگردد، چون در صورتی که بارگذاری فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که `exec` را فراخوانی کرده اطلاع داده می‌شود؟

اینجا هم مانند بخش wait، باید از مکانیزم lock استفاده کنیم؛ چرا که ما می‌خواهیم فراخوان سیستمی exec تا پایان اجرا شدن load صبر کند، که این عملا کاریست که semaphore برای ما می‌کند.
به این صورت عمل می‌کنیم که پیش از اینکه وارد exec شویم semaphore_down را صدا می‌زنیم تا مطمئن شویم تا وقتی که semaphore_up صدا زده نشده است، منتظر بماند.
و در نهایت هنگامی که کار تابع load تمام می‌شود، semaphore_up را صدا می‌زنیم تا موفقیت یا شکست خود را به ریسه‌ای که exec را فراخوانی کرده اطلاع دهد.

> پردازه‌ی والد P و پردازه‌ی فرزند C را درنظر بگیرید. هنگامی که P فراخوانی `wait(C)` را اجرا می‌کند و C  هنوز خارج نشده است، توضیح دهید که چگونه همگام‌سازی مناسب را برای جلوگیری از ایجاد شرایط مسابقه (race condition) پیاده‌سازی کرده‌اید. وقتی که C از قبل خارج شده باشد چطور؟ در هر حالت چگونه از آزاد شدن تمامی منابع اطمینان حاصل می‌کنید؟ اگر P بدون منتظر ماندن، قبل از C خارج شود چطور؟ اگر بدون منتظر ماندن بعد از C خارج شود چطور؟ آیا حالت‌های خاصی وجود دارد؟

زمانی که می‌خواهیم reference_count را تغییر دهیم، با  استفاده از rc_lock آن را lock می‌کنیم و تغییر را انجام می‌دهیم و سپس lock را آزاد می‌کنیم. با این کار برای تغییر reference_count حالت race به وجود نمی‌آید. در نهایت بررسی می‌کنیم که آیا reference_count برابر صفر است یا خیر و در صورت صفر بودن منابع را آزاد می‌کنیم.

### منطق طراحی

>
> به چه دلیل روش دسترسی به حافظه سطح کاربر از داخل هسته را این‌گونه پیاده‌سازی کرده‌اید؟

به دلیل سادگی مطابق روش اول توضیحات داک پینت اواس در این لینک عمل خواهیم کرد:
<https://cs162.org/static/proj/pintos-docs/docs/userprog/accessing-user-mem/>

> طراحی شما برای توصیف‌کننده‌های فایل چه نقاط قوت و ضعفی دارد؟

> در حالت پیش‌فرض نگاشت `tid` به `pid` یک نگاشت همانی است. اگر این را تغییر داده‌اید، روی‌کرد شما چه نقاط قوتی دارد؟

تغییری نداده‌ایم.

## سوالات افزون بر طراحی

>
> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی(esp) نامعتبر استفاده کرده است بیابید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.

تست sc-bad-sp اینگونه طراحی شده است.

```C
#include "tests/lib.h"
#include "tests/main.h"

void
test_main (void)
{
  asm volatile ("movl $.-(64*1024*1024), %esp; int $0x30");
  fail ("should have called exit(-1)");
}

```

در این تست یک مقدار منفی در اشاره‌گر پشته ریخته می‌شود که نامعتبر است و برنامه باید با -۱ خارج شود.

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی معتبر استفاده کرده ولی اشاره‌گر پشته آنقدر به مرز صفحه نزدیک است که برخی از آرگومان‌های فراخوانی سیستمی در جای نامعتبر مموری قرار گرفته اند مشخص کنید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.یک قسمت از خواسته‌های تمرین را که توسط مجموعه تست موجود تست نشده‌است، نام ببرید. سپس مشخص کنید تستی که این خواسته را پوشش بدهد چگونه باید باشد.

## سوالات نظرخواهی

پاسخ به این سوالات اختیاری است، ولی پاسخ به آن‌ها می‌تواند به ما در بهبود درس در ترم‌های آینده کمک کند. هر چه در ذهن خود دارید بگویید. این سوالات برای دریافت افکار شما هستند. هم‌چنین می‌توانید پاسخ خود را به صورت ناشناس در انتهای ترم ارائه دهید.

> به نظر شما، این تمرین یا هر یک از سه بخش آن، آسان یا سخت بودند؟ آیا وقت خیلی کم یا وقت خیلی زیادی گرفتند؟

> آیا شما بخشی را در تمرین یافتید که دید عمیق‌تری نسبت به طراحی سیستم عامل به شما بدهد؟

> آیا مسئله یا راهنمایی خاصی وجود دارد که بخواهید برای حل مسائل تمرین به دانشجویان ترم‌های آینده بگویید؟

> آیا توصیه‌ای برای دستیاران آموزشی دارید که چگونه دانشجویان را در ترم‌های آینده یا در ادامه‌ی ترم بهتر یاری کنند؟

> اگر نظر یا بازخورد دیگری دارید در این قسمت بنویسید.
